
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/d3-quadtree.v1.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
<script src="../../resource/lib/leaflet-heat.js"></script>
<script type="text/javascript"></script>

<h1></h1>
<div style="text-align: center">
    <div class="slidecontainer">
        Intensity:
        <input type="range" min="1" max="100" value="50" step="10" class="slider" id="rangeIntensity">
    </div>
    <div class="slidecontainer">
        Radius:
        <input type="range" min="1" max="100" value="50" step="10" class="slider" id="rangeRadius">
    </div>
    <div id="tooltip">Hello</div>
    <div id="geo-stats">Some stats here potentially ðŸŒŽ</div>
    <div id="geo-chart"><div id="mapid" style="width: 900px; height: 400px;"></div></div>
    <div id="spinner"></div>
</div>

<style>

div.tooltip {
    position: absolute;
    text-align: center;
    width: 400px;
    height: 100px;
    padding: 2px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 10px;
    border-radius: 8px;
    pointer-events: none;
    z-index: 1000;
}

</style>

<script>

var quadtree;

var mainmap = L.map('mapid').setView([40.8126, -73.980], 5);   // center position + zoom
console.log('Instantiate leaflet map ...')
// TODO: Persisting usage token ? (Should it be parametrised ?)
L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
    maxZoom: 18,
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
        'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
    id: 'mapbox/streets-v11',
    tileSize: 512,
    zoomOffset: -1
}).addTo(mainmap).set;

let Position = L.Control.extend({
    _container: null,
    options: {
        position: 'bottomleft'
    },

    onAdd: function (map) {
        var latlng = L.DomUtil.create('div', 'mouseposition');
        this._latlng = latlng;
        return latlng;
    },

    updateHTML: function(lat, lng) {
        var latlng = lat + " " + lng;
        //this._latlng.innerHTML = "Latitude: " + lat + "   Longitiude: " + lng;
        this._latlng.innerHTML = "LatLng: " + latlng;
    }
});

position = new Position();
mainmap.addControl(position);

var tooltip = d3.select("#tooltip")
    .append("div")
    .attr("class", "tooltip")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .text("I'm a circle!")
    .style("z-index", 1000);

var singleValueTemplate = "<ul></ul>";

function displayLocal(svg, closestMarker){

    console.log("console log closestMarker=", closestMarker);

    // create a tooltip

    svg.selectAll("myCircles")
        .attr("pointer-events", "visible")
        .data([closestMarker])
        .enter()
        .append("circle")
        .attr("cx", function(d) {
            // TODO: The following line should be moved to other location with access to `d`
            tooltip.html("<ul><b>Latitude</b>: "+d.lat+"</ul>"+"<ul><b>Longitude</b>: "+d.long+"</ul>")
            return mainmap.latLngToLayerPoint([d.lat, d.long]).x
        })
        .attr("cy", function(d) {
            return mainmap.latLngToLayerPoint([d.lat, d.long]).y
        })
        .attr("id", "circleBasicTooltip")
        .on('mouseover', function() { //function to add mouseover event
            tooltip.style("visibility", "visible")
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY - 28) + "px");
            d3.select(this).transition() //D3 selects the object we have moused over in order to perform operations on it
                .duration('50') //how long we are transitioning between the two states (works like keyframes)
                .attr("fill", "blue") //change the fill
                .attr('r', 10) //change radius
                .attr("stroke", "blue")
                .attr("stroke-width", 3)
                .attr("fill-opacity", .4)
        })
        .on('mouseout', function() { //reverse the action based on when we mouse off the the circle
            tooltip.style("visibility", "hidden")
            d3.select(this).transition()
                .duration('150')
                .attr("r", 5)
                .attr("fill", "transparent")
                .attr("fill-opacity", 0)
                .attr("stroke", 0)
                .attr("stroke-width", 0)
        })
        .attr("r", 5)
        .attr("fill", "transparent")
        .attr("fill-opacity", 0)
        .attr("stroke", 0)
        .attr("stroke-width", 0)
}

// Add a svg layer to the map
L.svg({clickable:true}).addTo(mainmap);
const overlay = d3.select(mainmap.getPanes().overlayPane)
const svg = overlay.select('svg').attr("pointer-events", "auto")

mainmap.addEventListener('mousemove', (event) => {
    let lat = Math.round(event.latlng.lat * 100000) / 100000;
    let long = Math.round(event.latlng.lng * 100000) / 100000;
    this.position.updateHTML(lat, long);
    var closestMarker = quadtree.find(lat, long, 10);
    displayLocal(svg, {lat: closestMarker[0], long: closestMarker[1] });
    console.log("localMarkers=", closestMarker);
});


// Initialization of storage variables
var heat;
var countUpdateMap = 0;
var gradient = 0;
var radius = 50;
var initial = true;
var intensity = 0.5;

// Init range and sliders
var rangeIntensity = document.getElementById("rangeIntensity");
// Update the current slider value (each time you drag the slider handle)
rangeIntensity.oninput = function() {
    intensity = this.value / 100;
    console.log("Value of rangeIntensity is set to: ", intensity);
    updateMapVisualisation(heat, gradient, radius, intensity, initial, svg);
    initial = false;
}

var rangeRadius = document.getElementById("rangeRadius");
// Update the current slider value (each time you drag the slider handle)
rangeRadius.oninput = function() {
    radius = 25;
    updateMapVisualisation(heat, gradient, radius, intensity, initial, svg);
    initial = false;
}

var geopoints = [];
for (var i = 0; i < 100000; i++) {
    geopoints.push([40.7551815+0.06*Math.random(), -73.9805255+0.06*Math.random()]);
}

console.log("geopoints=", geopoints);

var markers = [];
for (var i = 0; i < 100000; i++) {
    markers.push({
        lat: geopoints[i][0],
        long: geopoints[i][1]
    });
}

function handleMouseOver(d, i) {
    console.log("Display over");
    d3.select(this).attr({
        fill: "orange",
        r: 12
    });
    svg.append("text").attr({
        id: "t" + d.x + "-" + d.y + "-" + i,  // Create an id for text so we can select it later for removing on mouseout
        x: function() { d.cx },
        y: function() { d.cy }
    })
        .text(function() {
            return [d.cx, d.cy];  // Value of the text
        });
}

function handleMouseOut(d, i) {
     d3.select(this).attr({
        fill: "black",
        r: 3
    });
   d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
}

// Function that update circle position if something change
function update() {
    d3.selectAll("circle")
        .attr("cx", function(d){ return mainmap.latLngToLayerPoint([d.lat, d.long]).x })
        .attr("cy", function(d){ return mainmap.latLngToLayerPoint([d.lat, d.long]).y })
}

// If the user change the map (zoom or drag), I update circle position:
mainmap.on("moveend", update);

function updateMapVisualisation(targetLayer, gradient, radius, intensity, initial, svg){
     console.log("Updating the map visualisation with following argument:");
     console.log("gradient:", gradient);
     console.log("radius:", radius);
    console.log("intensity:", intensity);
    console.log("initial:", initial);
    // Feed visualisation with leaflet parameters
    countUpdateMap += 1;
    console.log("updateMapVisualisation");
    console.log("Updating only the visualisation on the map");
    if (!initial){
        targetLayer.remove();
    }

    quadtree = d3.quadtree()
        .extent([[-100, -100], [100, 100]])
        .addAll(geopoints);

    console.log("Done building quadtree");

    // If the user change the map (zoom or drag), I update circle position:
    mainmap.on("moveend", update);

    var wgeopoints = [];

    for (var i = 0; i < 1000; i++) {
        wgeopoints.push([geopoints[i][0], geopoints[i][1], intensity]);
    }

    targetLayer = L.heatLayer(wgeopoints, {radius: radius, gradient: gradient});
    // Add layer to global object mainmap (leaflet target map)
    targetLayer.addTo(mainmap);
    heat = targetLayer;
}

updateMapVisualisation(heat, gradient, radius, intensity, initial, svg);

</script>
